# Session Manager vs Long-term Memory ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥ÑÏÑú v1.0

**ÏûëÏÑ±Ïùº**: 2025-10-13
**Î≤ÑÏ†Ñ**: v1.0
**ÏûëÏÑ±Ïûê**: Claude Code
**Î™©Ï†Å**: SessionManagerÏôÄ Long-term MemoryÏùò Ïó≠Ìï† Íµ¨Î∂Ñ Î∞è PostgreSQL ÌÜµÌï© ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥Ñ

**Í¥ÄÎ†® Î¨∏ÏÑú**:
- [State/Context ÏÑ§Í≥Ñ Í≥ÑÌöçÏÑú v2.0](./plan_of_state_context_design_v2.md)

---

## üìã Î™©Ï∞®

1. [Í∞úÏöî](#Í∞úÏöî)
2. [SessionManager ÏÉÅÏÑ∏ ÏÑ§Í≥Ñ](#sessionmanager-ÏÉÅÏÑ∏-ÏÑ§Í≥Ñ)
3. [Long-term Memory ÏÉÅÏÑ∏ ÏÑ§Í≥Ñ](#long-term-memory-ÏÉÅÏÑ∏-ÏÑ§Í≥Ñ)
4. [Îëê ÏãúÏä§ÌÖúÏùò ÏÉÅÌò∏ÏûëÏö©](#Îëê-ÏãúÏä§ÌÖúÏùò-ÏÉÅÌò∏ÏûëÏö©)
5. [PostgreSQL ÌÜµÌï© Í≥ÑÌöç](#postgresql-ÌÜµÌï©-Í≥ÑÌöç)
6. [Íµ¨ÌòÑ Î°úÎìúÎßµ](#Íµ¨ÌòÑ-Î°úÎìúÎßµ)
7. [API ÏÑ§Í≥Ñ](#api-ÏÑ§Í≥Ñ)

---

## 1. Í∞úÏöî

### 1.1 Î∞∞Í≤Ω

ÌòÑÏû¨ ÏãúÏä§ÌÖúÏùÄ ÏÑ∏ Í∞ÄÏßÄ Ï†ÄÏû•ÏÜåÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§:

1. **SessionManager** (SQLite) - WebSocket ÏÑ∏ÏÖò Í¥ÄÎ¶¨
2. **Checkpointer** (SQLite) - LangGraph State Ï†ÄÏû•
3. **Long-term Memory** (ÎØ∏Íµ¨ÌòÑ) - ÎåÄÌôî Ïù¥Î†• Î∞è ÌïôÏäµ Îç∞Ïù¥ÌÑ∞

**Î¨∏Ï†úÏ†ê**:
- SQLite 3Í∞ú ÏÇ¨Ïö© ‚Üí Í¥ÄÎ¶¨ Î≥µÏû°ÎèÑ Ï¶ùÍ∞Ä
- Long-term Memory ÎØ∏Íµ¨ÌòÑ ‚Üí Í∞úÏù∏Ìôî Î∂àÍ∞ÄÎä•
- SessionManagerÏôÄ MemoryÏùò Ïó≠Ìï† ÌòºÎèô

**Ìï¥Í≤∞ Î∞©Ïïà**:
- Î™®Îì† Ï†ÄÏû•ÏÜåÎ•º PostgreSQLÎ°ú ÌÜµÌï©
- SessionManagerÏôÄ MemoryÏùò Ïó≠Ìï† Î™ÖÌôïÌûà Íµ¨Î∂Ñ
- ÌÜµÌï© ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥Ñ

---

### 1.2 ÌïµÏã¨ Í∞úÎÖê ÎπÑÍµê

| Íµ¨Î∂Ñ | SessionManager | Long-term Memory |
|------|----------------|------------------|
| **Ïó≠Ìï†** | üîê WebSocket Ïó∞Í≤∞ ÏÑ∏ÏÖò Í¥ÄÎ¶¨ | üß† ÎåÄÌôî ÎÇ¥Ïö© Î∞è ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• |
| **Î™©Ï†Å** | Ïù∏Ï¶ù Î∞è ÏÑ∏ÏÖò Ï∂îÏ†Å (Ïù∏ÌîÑÎùº) | Í∞úÏù∏Ìôî Î∞è Î¨∏Îß• Ïù¥Ìï¥ (ÎπÑÏ¶àÎãàÏä§) |
| **Îç∞Ïù¥ÌÑ∞** | session_id, user_id, ÎßåÎ£åÏãúÍ∞Ñ | ÎåÄÌôî Ïù¥Î†•, ÏÑ†Ìò∏ÎèÑ, ÏóîÌã∞Ìã∞ Ï∂îÏ†Å |
| **ÏÉùÎ™ÖÏ£ºÍ∏∞** | Îã®Í∏∞ (24ÏãúÍ∞Ñ TTL) | Ïû•Í∏∞ (ÏòÅÍµ¨ Ï†ÄÏû•) |
| **ÏÇ≠Ï†ú ÏãúÏ†ê** | ÏÑ∏ÏÖò ÎßåÎ£å Ïãú ÏûêÎèô ÏÇ≠Ï†ú | ÏÇ¨Ïö©Ïûê Í≥ÑÏ†ï ÏÇ≠Ï†ú ÏãúÍπåÏßÄ Î≥¥Í¥Ä |
| **ÎπÑÏú†** | Ï∂úÏûÖÏ¶ù, Î≤àÌò∏Ìëú | Îã®Í≥® Ïπ¥Îìú, Ï£ºÎ¨∏ Ïù¥Î†• |
| **ÌòÑÏû¨ ÏÉÅÌÉú** | ‚úÖ Íµ¨ÌòÑÎê® (SQLite) | ‚è≥ ÎØ∏Íµ¨ÌòÑ |
| **DB** | PostgreSQL Ï†ÑÌôò ÏòàÏ†ï | PostgreSQL Ïã†Í∑ú Íµ¨Ï∂ï |

---

### 1.3 ÏÇ¨Ïö© ÏãúÎÇòÎ¶¨Ïò§ ÏòàÏãú

#### ÏãúÎÇòÎ¶¨Ïò§ 1: Ï≤´ Î∞©Î¨∏ ÏÇ¨Ïö©Ïûê (ÎπÑÎ°úÍ∑∏Ïù∏)

```
1. ÏÇ¨Ïö©ÏûêÍ∞Ä ÏõπÏÇ¨Ïù¥Ìä∏ Ï†ëÏÜç
   ‚Üì
SessionManager.create_session(user_id=None)
   ‚Üí session_id: "session-xyz-789" ÏÉùÏÑ±
   ‚Üí 24ÏãúÍ∞Ñ Ïú†Ìö®
   ‚Üì
2. ÏßàÎ¨∏: "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò"
   ‚Üì
TeamSupervisor Ï≤òÎ¶¨
   SharedState {
       session_id: "session-xyz-789",
       user_id: None,  # Î°úÍ∑∏Ïù∏ ÏïàÌï®
       query: "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò"
   }
   ‚Üì
3. ÏùëÎãµ: "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏ 10Í±¥ Ï∞æÏïòÏäµÎãàÎã§"
   ‚Üì
Memory Ï†ÄÏû• ‚ùå (user_id ÏóÜÏúºÎØÄÎ°ú Ï†ÄÏû• ÏïàÌï®)
   ‚Üí ÏùºÌöåÏÑ± ÎåÄÌôîÎßå Ï≤òÎ¶¨
   ‚Üì
4. 24ÏãúÍ∞Ñ ÌõÑ session ÏûêÎèô ÎßåÎ£å
```

---

#### ÏãúÎÇòÎ¶¨Ïò§ 2: Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê (Îã®Í≥®)

```
1. Î°úÍ∑∏Ïù∏ ÌõÑ Ï†ëÏÜç
   ‚Üì
SessionManager.create_session(user_id=42)
   ‚Üí session_id: "session-abc-123"
   ‚Üí user_id: 42 Ïó∞Í≤∞
   ‚Üì
2. ÏßàÎ¨∏: "ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò" (ÏßÄÏó≠ ÎØ∏ÏßÄÏ†ï)
   ‚Üì
Planning Agent
   ‚Üì Memory Ï°∞Ìöå
Memory.get_user_preferences(user_id=42)
   ‚Üí preferred_regions: ["Í∞ïÎÇ®Íµ¨", "ÏÑúÏ¥àÍµ¨"]
   ‚Üí ÏûêÏ£º Í≤ÄÏÉâÌïòÎäî ÏßÄÏó≠ ÌôïÏù∏
   ‚Üì
Planning Agent: "Ïù¥ ÏÇ¨Ïö©ÏûêÎäî Ï£ºÎ°ú Í∞ïÎÇ®Íµ¨Î•º Í≤ÄÏÉâÌïòÎãàÍπå Í∞ïÎÇ®Íµ¨Î°ú Í≤ÄÏÉâÌïòÏûê"
   ‚Üì
3. ÏùëÎãµ: "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏ 10Í±¥ Ï∞æÏïòÏäµÎãàÎã§"
   ‚Üì
Memory Ï†ÄÏû• ‚úÖ
   ConversationMemory: ÎåÄÌôî ÎÇ¥Ïó≠ Ï†ÄÏû•
   UserPreference: Í∞ïÎÇ®Íµ¨ Í≤ÄÏÉâ Ïπ¥Ïö¥Ìä∏ +1
   EntityMemory: "Í∞ïÎÇ®Íµ¨" ÏóîÌã∞Ìã∞ ÏóÖÎç∞Ïù¥Ìä∏
```

---

#### ÏãúÎÇòÎ¶¨Ïò§ 3: Î¨∏Îß• Ï∞∏Ï°∞ (Í≥ºÍ±∞ ÎåÄÌôî Í∏∞Ïñµ)

```
1. Ï≤´ Î≤àÏß∏ ÏßàÎ¨∏
user: "Í∞ïÎÇ®Íµ¨ 5Ïñµ Ïù¥Ìïò ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò"
   ‚Üì
assistant: "Í∞ïÎÇ® ÏïÑÌååÌä∏ A, B, C 3Í±¥ Ï∞æÏïòÏäµÎãàÎã§"
   ‚Üì
Memory.store_conversation(
    session_id="session-abc-123",
    user_id=42,
    query="Í∞ïÎÇ®Íµ¨ 5Ïñµ Ïù¥Ìïò ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò",
    response="Í∞ïÎÇ® ÏïÑÌååÌä∏ A, B, C 3Í±¥...",
    entities=["Í∞ïÎÇ®Íµ¨", "5Ïñµ", "ÏïÑÌååÌä∏"]
)
   ‚Üì
2. 10Î∂Ñ ÌõÑ, Îëê Î≤àÏß∏ ÏßàÎ¨∏
user: "Ï≤´ Î≤àÏß∏ Îß§Î¨º ÏÉÅÏÑ∏Ìûà Î≥¥Ïó¨Ï§ò"
   ‚Üì
Planning Agent
   ‚Üì Memory Ï°∞Ìöå
Memory.load_recent_context(user_id=42, limit=1)
   ‚Üí Ïù¥Ï†Ñ ÎåÄÌôî: "Í∞ïÎÇ® ÏïÑÌååÌä∏ A, B, C"
   ‚Üí "Ï≤´ Î≤àÏß∏ Îß§Î¨º" = Í∞ïÎÇ® ÏïÑÌååÌä∏ A
   ‚Üì
assistant: "Í∞ïÎÇ® ÏïÑÌååÌä∏ A ÏÉÅÏÑ∏ Ï†ïÎ≥¥ÏûÖÎãàÎã§..."
```

---

## 2. SessionManager ÏÉÅÏÑ∏ ÏÑ§Í≥Ñ

### 2.1 ÌòÑÏû¨ Íµ¨Ï°∞ (SQLite)

**ÌååÏùº**: `backend/app/api/session_manager.py`
**DB**: `backend/data/system/sessions/sessions.db`

**ÌÖåÏù¥Î∏î Ïä§ÌÇ§Îßà**:
```sql
CREATE TABLE sessions (
    session_id TEXT PRIMARY KEY,          -- "session-{uuid}"
    user_id TEXT,                         -- ÏÇ¨Ïö©Ïûê ID (Î°úÍ∑∏Ïù∏ Ïãú)
    metadata TEXT,                        -- JSON Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    created_at TIMESTAMP NOT NULL,
    expires_at TIMESTAMP NOT NULL,        -- 24ÏãúÍ∞Ñ ÌõÑ ÏûêÎèô ÎßåÎ£å
    last_activity TIMESTAMP NOT NULL,
    request_count INTEGER DEFAULT 0
);

CREATE INDEX idx_expires_at ON sessions(expires_at);
```

**Ï£ºÏöî Î©îÏÑúÎìú**:
```python
class SessionManager:
    def create_session(user_id: Optional[str], metadata: Optional[Dict]) -> Tuple[str, datetime]
    def get_session(session_id: str) -> Optional[Dict]
    def update_activity(session_id: str) -> bool
    def delete_session(session_id: str) -> bool
    def cleanup_expired_sessions() -> int  # ÎßåÎ£åÎêú ÏÑ∏ÏÖò Ï†ïÎ¶¨
    def get_user_sessions(user_id: str) -> List[Dict]
```

---

### 2.2 PostgreSQL Ï†ÑÌôò ÏÑ§Í≥Ñ

**Î™©Ìëú**: SQLite ‚Üí PostgreSQL ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò

#### 2.2.1 DB Î™®Îç∏ ÏÑ§Í≥Ñ

**ÌååÏùº**: `backend/app/models/session.py` (Ïã†Í∑ú)

```python
from sqlalchemy import Column, Integer, String, TIMESTAMP, ForeignKey, JSON, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from app.db.postgre_db import Base
import uuid

class WebSocketSession(Base):
    """WebSocket ÏÑ∏ÏÖò Í¥ÄÎ¶¨ (Í∏∞Ï°¥ SessionManager)"""
    __tablename__ = "websocket_sessions"

    # Primary Key
    session_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # User Ïó∞Í≤∞
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True, index=True)
    # nullable=True: ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎèÑ Ï†ëÏÜç Í∞ÄÎä•

    # Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    metadata = Column(JSON, default={})

    # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False)
    expires_at = Column(TIMESTAMP(timezone=True), nullable=False)  # created_at + 24h
    last_activity = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False)

    # ÌÜµÍ≥Ñ
    request_count = Column(Integer, default=0)

    # Relationships
    user = relationship("User", back_populates="websocket_sessions")

    # Indexes
    __table_args__ = (
        Index('idx_expires_at', 'expires_at'),  # ÎßåÎ£å ÏÑ∏ÏÖò Ï†ïÎ¶¨Ïö©
        Index('idx_user_sessions', 'user_id', 'created_at'),  # ÏÇ¨Ïö©ÏûêÎ≥Ñ ÏÑ∏ÏÖò Ï°∞Ìöå
    )
```

**Pydantic Schema**:

**ÌååÏùº**: `backend/app/schemas/session.py` (Ïã†Í∑ú)

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from uuid import UUID

class WebSocketSessionCreate(BaseModel):
    user_id: Optional[int] = None
    metadata: Optional[dict] = {}

class WebSocketSessionResponse(BaseModel):
    session_id: UUID
    user_id: Optional[int]
    created_at: datetime
    expires_at: datetime
    last_activity: datetime
    request_count: int

    class Config:
        from_attributes = True
```

---

#### 2.2.2 SessionManager Î¶¨Ìå©ÌÜ†ÎßÅ

**ÌååÏùº**: `backend/app/api/session_manager.py` (ÏàòÏ†ï)

```python
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.postgre_db import SessionLocal
from app.models.session import WebSocketSession
from datetime import datetime, timedelta
import uuid

class SessionManager:
    """PostgreSQL Í∏∞Î∞ò ÏÑ∏ÏÖò Í¥ÄÎ¶¨"""

    def __init__(self, session_ttl_hours: int = 24):
        self.session_ttl = timedelta(hours=session_ttl_hours)

    async def create_session(
        self,
        user_id: Optional[int] = None,
        metadata: Optional[Dict] = None
    ) -> Tuple[str, datetime]:
        """
        ÏÉà ÏÑ∏ÏÖò ÏÉùÏÑ± (PostgreSQL)

        Returns:
            (session_id, expires_at)
        """
        async with SessionLocal() as db:
            session_id = uuid.uuid4()
            created_at = datetime.now()
            expires_at = created_at + self.session_ttl

            ws_session = WebSocketSession(
                session_id=session_id,
                user_id=user_id,
                metadata=metadata or {},
                created_at=created_at,
                expires_at=expires_at,
                last_activity=created_at,
                request_count=0
            )

            db.add(ws_session)
            await db.commit()
            await db.refresh(ws_session)

            logger.info(f"Session created: {session_id}, user_id: {user_id}")
            return str(session_id), expires_at

    async def get_session(self, session_id: str) -> Optional[Dict]:
        """ÏÑ∏ÏÖò Ï°∞Ìöå"""
        async with SessionLocal() as db:
            result = await db.execute(
                select(WebSocketSession).where(
                    WebSocketSession.session_id == uuid.UUID(session_id)
                )
            )
            session = result.scalar_one_or_none()

            if not session:
                return None

            # ÎßåÎ£å Ï≤¥ÌÅ¨
            if session.expires_at < datetime.now():
                logger.info(f"Session expired: {session_id}")
                await self.delete_session(session_id)
                return None

            return {
                "session_id": str(session.session_id),
                "user_id": session.user_id,
                "metadata": session.metadata,
                "created_at": session.created_at,
                "expires_at": session.expires_at,
                "last_activity": session.last_activity,
                "request_count": session.request_count
            }

    async def update_activity(self, session_id: str) -> bool:
        """ÏÑ∏ÏÖò ÌôúÎèô ÏóÖÎç∞Ïù¥Ìä∏"""
        async with SessionLocal() as db:
            result = await db.execute(
                update(WebSocketSession)
                .where(WebSocketSession.session_id == uuid.UUID(session_id))
                .values(
                    last_activity=datetime.now(),
                    request_count=WebSocketSession.request_count + 1
                )
            )
            await db.commit()
            return result.rowcount > 0

    async def delete_session(self, session_id: str) -> bool:
        """ÏÑ∏ÏÖò ÏÇ≠Ï†ú"""
        async with SessionLocal() as db:
            result = await db.execute(
                delete(WebSocketSession)
                .where(WebSocketSession.session_id == uuid.UUID(session_id))
            )
            await db.commit()
            return result.rowcount > 0

    async def cleanup_expired_sessions(self) -> int:
        """ÎßåÎ£åÎêú ÏÑ∏ÏÖò Ï†ïÎ¶¨ (Cron job)"""
        async with SessionLocal() as db:
            result = await db.execute(
                delete(WebSocketSession)
                .where(WebSocketSession.expires_at < datetime.now())
            )
            await db.commit()
            count = result.rowcount
            logger.info(f"Cleaned up {count} expired sessions")
            return count

    async def get_user_sessions(self, user_id: int) -> List[Dict]:
        """ÏÇ¨Ïö©ÏûêÏùò Î™®Îì† ÌôúÏÑ± ÏÑ∏ÏÖò Ï°∞Ìöå"""
        async with SessionLocal() as db:
            result = await db.execute(
                select(WebSocketSession)
                .where(
                    WebSocketSession.user_id == user_id,
                    WebSocketSession.expires_at > datetime.now()
                )
                .order_by(WebSocketSession.created_at.desc())
            )
            sessions = result.scalars().all()

            return [
                {
                    "session_id": str(s.session_id),
                    "created_at": s.created_at,
                    "expires_at": s.expires_at,
                    "last_activity": s.last_activity,
                    "request_count": s.request_count
                }
                for s in sessions
            ]
```

---

#### 2.2.3 ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í≥ÑÌöç

**Îã®Í≥Ñ 1: DB Î™®Îç∏ ÏÉùÏÑ±**
```bash
# Alembic migration ÏÉùÏÑ±
alembic revision --autogenerate -m "Add WebSocketSession model"
alembic upgrade head
```

**Îã®Í≥Ñ 2: SessionManager ÍµêÏ≤¥**
```python
# Í∏∞Ï°¥ SQLite SessionManager ÏÇ¨Ïö© ÏΩîÎìú
session_manager = SessionManager(db_path="sessions.db")

# PostgreSQL SessionManagerÎ°ú ÍµêÏ≤¥
session_manager = SessionManager(session_ttl_hours=24)
# DB Í≤ΩÎ°ú Î∂àÌïÑÏöî (PostgreSQL Ïó∞Í≤∞ÏùÄ app.db.postgre_dbÏóêÏÑú Í¥ÄÎ¶¨)
```

**Îã®Í≥Ñ 3: Í∏∞Ï°¥ SQLite Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò (ÏÑ†ÌÉù)**
```python
# Í∏∞Ï°¥ sessions.dbÏóêÏÑú ÌôúÏÑ± ÏÑ∏ÏÖò Ï∂îÏ∂ú
import sqlite3
conn = sqlite3.connect("backend/data/system/sessions/sessions.db")
active_sessions = conn.execute(
    "SELECT * FROM sessions WHERE expires_at > datetime('now')"
).fetchall()

# PostgreSQLÎ°ú ÏÇΩÏûÖ
for session in active_sessions:
    await session_manager.create_session(
        user_id=session["user_id"],
        metadata=json.loads(session["metadata"])
    )
```

**Îã®Í≥Ñ 4: ÌÖåÏä§Ìä∏ Î∞è Î∞∞Ìè¨**
- [ ] Unit Test: SessionManager Î©îÏÑúÎìú ÌÖåÏä§Ìä∏
- [ ] Integration Test: WebSocket Ïó∞Í≤∞ ÏãúÎÇòÎ¶¨Ïò§
- [ ] Load Test: ÎèôÏãú ÏÑ∏ÏÖò 1000Í∞ú Ï≤òÎ¶¨
- [ ] Î∞∞Ìè¨ ÌõÑ Î™®ÎãàÌÑ∞ÎßÅ

---

## 3. Long-term Memory ÏÉÅÏÑ∏ ÏÑ§Í≥Ñ

### 3.1 Í∞úÏöî

**Î™©Ï†Å**: ÎåÄÌôî Ïù¥Î†•, ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ, ÌïôÏäµÎêú Ìå®ÌÑ¥ÏùÑ ÏòÅÍµ¨ Ï†ÄÏû•ÌïòÏó¨ Í∞úÏù∏ÌôîÎêú ÏÑúÎπÑÏä§ Ï†úÍ≥µ

**Ï£ºÏöî Í∏∞Îä•**:
1. **ÎåÄÌôî Ïù¥Î†• Ï†ÄÏû•**: Î™®Îì† ÎåÄÌôî ÌÑ¥ Í∏∞Î°ù
2. **ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ ÌïôÏäµ**: ÏûêÏ£º Í≤ÄÏÉâÌïòÎäî ÏßÄÏó≠, Í∞ÄÍ≤©ÎåÄ, Îß§Î¨º ÌÉÄÏûÖ
3. **ÏóîÌã∞Ìã∞ Ï∂îÏ†Å**: ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûêÏ£º Ïñ∏Í∏âÌïòÎäî ÏóîÌã∞Ìã∞ (ÏßÄÏó≠, Îß§Î¨º Îì±)
4. **Î¨∏Îß• Ïù¥Ìï¥**: Í≥ºÍ±∞ ÎåÄÌôîÎ•º Ï∞∏Ï°∞ÌïòÏó¨ "Í∑∏ Îß§Î¨º" Í∞ôÏùÄ ÎåÄÎ™ÖÏÇ¨ Ìï¥ÏÑù

---

### 3.2 DB Î™®Îç∏ ÏÑ§Í≥Ñ

#### 3.2.1 ConversationMemory (ÎåÄÌôî Ïù¥Î†•)

**ÌååÏùº**: `backend/app/models/memory.py` (Ïã†Í∑ú)

```python
from sqlalchemy import Column, Integer, String, Text, Float, TIMESTAMP, ForeignKey, Index
from sqlalchemy.dialects.postgresql import UUID, ARRAY, JSON
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.postgre_db import Base

class ConversationMemory(Base):
    """ÎåÄÌôî Ïù¥Î†• Î©îÎ™®Î¶¨"""
    __tablename__ = "conversation_memories"

    # Primary Key
    id = Column(Integer, primary_key=True, index=True)

    # Session & User Ïó∞Í≤∞
    session_id = Column(UUID(as_uuid=True), ForeignKey("chat_sessions.id"), nullable=False, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)

    # ÎåÄÌôî ÌÑ¥ Ï†ïÎ≥¥
    turn_number = Column(Integer, nullable=False)  # ÏÑ∏ÏÖò ÎÇ¥ Î™á Î≤àÏß∏ ÎåÄÌôîÏù∏ÏßÄ
    user_query = Column(Text, nullable=False)
    assistant_response = Column(Text, nullable=False)

    # ÏùòÎèÑ Î∂ÑÏÑù Í≤∞Í≥º
    intent_type = Column(String(50))  # "legal_consult", "market_inquiry", "property_search" Îì±
    intent_confidence = Column(Float)  # 0.0 ~ 1.0

    # Ïã§Ìñâ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    teams_used = Column(ARRAY(String))  # ["search", "analysis"]
    tools_used = Column(ARRAY(String))  # ["legal_search", "market_data"]
    execution_time_ms = Column(Integer)  # Ïã§Ìñâ ÏãúÍ∞Ñ (Î∞ÄÎ¶¨Ï¥à)

    # Ï∂îÏ∂úÎêú ÏóîÌã∞Ìã∞
    entities = Column(JSON)  # {"location": ["Í∞ïÎÇ®Íµ¨"], "price": ["5Ïñµ"], "property_type": ["ÏïÑÌååÌä∏"]}

    # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False)

    # Relationships
    session = relationship("ChatSession", back_populates="conversation_memories")
    user = relationship("User", back_populates="conversation_memories")

    # Indexes
    __table_args__ = (
        Index('idx_session_turn', 'session_id', 'turn_number'),  # ÏÑ∏ÏÖòÎ≥Ñ ÎåÄÌôî ÏàúÏÑú Ï°∞Ìöå
        Index('idx_user_recent', 'user_id', 'created_at'),       # ÏÇ¨Ïö©ÏûêÎ≥Ñ ÏµúÍ∑º ÎåÄÌôî Ï°∞Ìöå
        Index('idx_intent_type', 'intent_type'),                 # ÏùòÎèÑÎ≥Ñ ÎåÄÌôî ÌÜµÍ≥Ñ
    )
```

---

#### 3.2.2 UserPreference (ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ)

```python
class UserPreference(Base):
    """ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ Î©îÎ™®Î¶¨ (ÌïôÏäµÎêú Ìå®ÌÑ¥)"""
    __tablename__ = "user_preferences"

    # Primary Key
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True, nullable=False)

    # ÏßÄÏó≠ ÏÑ†Ìò∏ÎèÑ
    preferred_regions = Column(ARRAY(String))  # ["Í∞ïÎÇ®Íµ¨", "ÏÑúÏ¥àÍµ¨"]
    region_search_counts = Column(JSON)  # {"Í∞ïÎÇ®Íµ¨": 25, "ÏÑúÏ¥àÍµ¨": 10}

    # Í∞ÄÍ≤© ÏÑ†Ìò∏ÎèÑ
    preferred_price_range = Column(JSON)  # {"min": 40000, "max": 60000} (ÎßåÏõê)
    avg_searched_price = Column(Integer)  # ÌèâÍ∑† Í≤ÄÏÉâ Í∞ÄÍ≤©

    # Îß§Î¨º ÌÉÄÏûÖ ÏÑ†Ìò∏ÎèÑ
    preferred_property_types = Column(ARRAY(String))  # ["APARTMENT", "OFFICETEL"]
    property_type_counts = Column(JSON)  # {"APARTMENT": 30, "OFFICETEL": 5}

    # Í≤ÄÏÉâ Ìå®ÌÑ¥
    frequent_queries = Column(JSON)  # [{"query": "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏", "count": 15, "last_searched": "2025-10-13"}]
    search_keywords = Column(ARRAY(String))  # ["ÏßÄÌïòÏ≤†", "ÌïôÍµê", "Ïã†Ï∂ï"]

    # Îß§Î¨º ÏÉÅÌò∏ÏûëÏö©
    viewed_properties = Column(ARRAY(Integer))  # Ï°∞ÌöåÌïú Îß§Î¨º ID Î™©Î°ù (ÏµúÍ∑º 100Í∞ú)
    favorited_properties = Column(ARRAY(Integer))  # Ï∞úÌïú Îß§Î¨º ID Î™©Î°ù

    # ÏãúÍ∞ÑÎåÄ Ìå®ÌÑ¥
    active_hours = Column(JSON)  # {"morning": 5, "afternoon": 10, "evening": 20, "night": 3}

    # ÏµúÏ¢Ö ÏóÖÎç∞Ïù¥Ìä∏
    last_search_context = Column(JSON)  # ÎßàÏßÄÎßâ Í≤ÄÏÉâ Ïª®ÌÖçÏä§Ìä∏ (Î¨∏Îß• Ïú†ÏßÄÏö©)

    # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
    updated_at = Column(TIMESTAMP(timezone=True), onupdate=func.now())

    # Relationships
    user = relationship("User", back_populates="preference")
```

---

#### 3.2.3 EntityMemory (ÏóîÌã∞Ìã∞ Ï∂îÏ†Å)

```python
class EntityMemory(Base):
    """ÏóîÌã∞Ìã∞ Ï∂îÏ∂ú Î∞è Ï∂îÏ†Å Î©îÎ™®Î¶¨"""
    __tablename__ = "entity_memories"

    # Primary Key
    id = Column(Integer, primary_key=True)

    # User Ïó∞Í≤∞
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)

    # ÏóîÌã∞Ìã∞ Ï†ïÎ≥¥
    entity_type = Column(String(50), nullable=False)  # "location", "price", "property_id", "date" Îì±
    entity_value = Column(String(255), nullable=False)  # "Í∞ïÎÇ®Íµ¨", "5Ïñµ", "123456"
    entity_normalized = Column(String(255))  # Ï†ïÍ∑úÌôîÎêú Í∞í ("5Ïñµ" ‚Üí "500000000")

    # Î¨∏Îß• Ï†ïÎ≥¥
    entity_context = Column(Text)  # ÏóîÌã∞Ìã∞Í∞Ä Ïñ∏Í∏âÎêú Î¨∏Îß• (ÏµúÍ∑º 3Í∞ú)
    related_entities = Column(JSON)  # Ìï®Íªò Ïñ∏Í∏âÎêú Îã§Î•∏ ÏóîÌã∞Ìã∞ {"price": ["5Ïñµ"], "property_type": ["ÏïÑÌååÌä∏"]}

    # ÎπàÎèÑ Î∞è Ï§ëÏöîÎèÑ
    mention_count = Column(Integer, default=1)  # Ïñ∏Í∏â ÌöüÏàò
    importance_score = Column(Float, default=1.0)  # Ï§ëÏöîÎèÑ Ï†êÏàò (ÎπàÎèÑ Í∏∞Î∞ò)

    # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ
    first_mentioned_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
    last_mentioned_at = Column(TIMESTAMP(timezone=True), server_default=func.now())

    # Relationships
    user = relationship("User", back_populates="entity_memories")

    # Indexes
    __table_args__ = (
        Index('idx_entity_lookup', 'user_id', 'entity_type', 'entity_value'),  # Îπ†Î•∏ ÏóîÌã∞Ìã∞ Ï°∞Ìöå
        Index('idx_importance', 'user_id', 'importance_score'),                 # Ï§ëÏöî ÏóîÌã∞Ìã∞ Ï†ïÎ†¨
    )
```

---

### 3.3 Memory Service Íµ¨ÌòÑ

**ÌååÏùº**: `backend/app/service_agent/memory/memory_service.py` (Ïã†Í∑ú)

```python
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from sqlalchemy import select, update, delete, func
from app.db.postgre_db import SessionLocal
from app.models.memory import ConversationMemory, UserPreference, EntityMemory

class LongTermMemoryService:
    """Long-term Memory Í¥ÄÎ¶¨ ÏÑúÎπÑÏä§"""

    # ============================================================================
    # 1. ÎåÄÌôî Ïù¥Î†• Í¥ÄÎ¶¨
    # ============================================================================

    async def store_conversation(
        self,
        session_id: str,
        user_id: int,
        turn_number: int,
        user_query: str,
        assistant_response: str,
        intent_type: str,
        intent_confidence: float,
        teams_used: List[str],
        tools_used: List[str],
        execution_time_ms: int,
        entities: Dict[str, List[str]]
    ) -> int:
        """
        ÎåÄÌôî ÌÑ¥ Ï†ÄÏû•

        Returns:
            conversation_id
        """
        async with SessionLocal() as db:
            conversation = ConversationMemory(
                session_id=session_id,
                user_id=user_id,
                turn_number=turn_number,
                user_query=user_query,
                assistant_response=assistant_response,
                intent_type=intent_type,
                intent_confidence=intent_confidence,
                teams_used=teams_used,
                tools_used=tools_used,
                execution_time_ms=execution_time_ms,
                entities=entities,
                created_at=datetime.now()
            )

            db.add(conversation)
            await db.commit()
            await db.refresh(conversation)

            logger.info(f"Conversation stored: user={user_id}, turn={turn_number}")
            return conversation.id

    async def load_recent_context(
        self,
        user_id: int,
        limit: int = 5
    ) -> List[Dict[str, Any]]:
        """
        ÏµúÍ∑º ÎåÄÌôî Ïª®ÌÖçÏä§Ìä∏ Î°úÎìú

        Args:
            user_id: ÏÇ¨Ïö©Ïûê ID
            limit: ÏµúÍ∑º NÍ∞ú ÎåÄÌôî

        Returns:
            ÎåÄÌôî Ïù¥Î†• Î¶¨Ïä§Ìä∏ (ÏµúÏã†Ïàú)
        """
        async with SessionLocal() as db:
            result = await db.execute(
                select(ConversationMemory)
                .where(ConversationMemory.user_id == user_id)
                .order_by(ConversationMemory.created_at.desc())
                .limit(limit)
            )
            conversations = result.scalars().all()

            return [
                {
                    "turn_number": c.turn_number,
                    "user_query": c.user_query,
                    "assistant_response": c.assistant_response,
                    "intent_type": c.intent_type,
                    "entities": c.entities,
                    "created_at": c.created_at.isoformat()
                }
                for c in reversed(conversations)  # Ïò§ÎûòÎêú Í≤ÉÎ∂ÄÌÑ∞ Ï†ïÎ†¨
            ]

    async def get_session_conversations(
        self,
        session_id: str
    ) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï ÏÑ∏ÏÖòÏùò Ï†ÑÏ≤¥ ÎåÄÌôî Ïù¥Î†• Ï°∞Ìöå"""
        async with SessionLocal() as db:
            result = await db.execute(
                select(ConversationMemory)
                .where(ConversationMemory.session_id == session_id)
                .order_by(ConversationMemory.turn_number)
            )
            conversations = result.scalars().all()

            return [
                {
                    "turn_number": c.turn_number,
                    "user_query": c.user_query,
                    "assistant_response": c.assistant_response,
                    "created_at": c.created_at.isoformat()
                }
                for c in conversations
            ]

    # ============================================================================
    # 2. ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ Í¥ÄÎ¶¨
    # ============================================================================

    async def get_user_preferences(
        self,
        user_id: int
    ) -> Optional[Dict[str, Any]]:
        """ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ Ï°∞Ìöå"""
        async with SessionLocal() as db:
            result = await db.execute(
                select(UserPreference)
                .where(UserPreference.user_id == user_id)
            )
            pref = result.scalar_one_or_none()

            if not pref:
                return None

            return {
                "preferred_regions": pref.preferred_regions,
                "preferred_price_range": pref.preferred_price_range,
                "preferred_property_types": pref.preferred_property_types,
                "frequent_queries": pref.frequent_queries,
                "search_keywords": pref.search_keywords
            }

    async def update_region_preference(
        self,
        user_id: int,
        region: str
    ):
        """ÏßÄÏó≠ Í≤ÄÏÉâ Ïπ¥Ïö¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏"""
        async with SessionLocal() as db:
            # Í∏∞Ï°¥ ÏÑ†Ìò∏ÎèÑ Ï°∞Ìöå
            result = await db.execute(
                select(UserPreference)
                .where(UserPreference.user_id == user_id)
            )
            pref = result.scalar_one_or_none()

            if not pref:
                # Ï≤´ ÏÑ†Ìò∏ÎèÑ ÏÉùÏÑ±
                pref = UserPreference(
                    user_id=user_id,
                    preferred_regions=[region],
                    region_search_counts={region: 1}
                )
                db.add(pref)
            else:
                # Ïπ¥Ïö¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                counts = pref.region_search_counts or {}
                counts[region] = counts.get(region, 0) + 1

                # ÏÉÅÏúÑ 3Í∞ú ÏßÄÏó≠ Ï∂îÏ∂ú
                top_regions = sorted(counts.items(), key=lambda x: x[1], reverse=True)[:3]

                await db.execute(
                    update(UserPreference)
                    .where(UserPreference.user_id == user_id)
                    .values(
                        preferred_regions=[r[0] for r in top_regions],
                        region_search_counts=counts,
                        updated_at=datetime.now()
                    )
                )

            await db.commit()

    async def update_price_preference(
        self,
        user_id: int,
        min_price: Optional[int],
        max_price: Optional[int]
    ):
        """Í∞ÄÍ≤© Î≤îÏúÑ ÏÑ†Ìò∏ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏"""
        async with SessionLocal() as db:
            result = await db.execute(
                select(UserPreference)
                .where(UserPreference.user_id == user_id)
            )
            pref = result.scalar_one_or_none()

            price_range = {}
            if min_price:
                price_range["min"] = min_price
            if max_price:
                price_range["max"] = max_price

            if not pref:
                pref = UserPreference(
                    user_id=user_id,
                    preferred_price_range=price_range
                )
                db.add(pref)
            else:
                await db.execute(
                    update(UserPreference)
                    .where(UserPreference.user_id == user_id)
                    .values(
                        preferred_price_range=price_range,
                        updated_at=datetime.now()
                    )
                )

            await db.commit()

    async def add_viewed_property(
        self,
        user_id: int,
        property_id: int
    ):
        """Ï°∞ÌöåÌïú Îß§Î¨º Ï∂îÍ∞Ä (ÏµúÍ∑º 100Í∞ú Ïú†ÏßÄ)"""
        async with SessionLocal() as db:
            result = await db.execute(
                select(UserPreference)
                .where(UserPreference.user_id == user_id)
            )
            pref = result.scalar_one_or_none()

            if not pref:
                pref = UserPreference(
                    user_id=user_id,
                    viewed_properties=[property_id]
                )
                db.add(pref)
            else:
                viewed = pref.viewed_properties or []
                viewed.append(property_id)
                viewed = viewed[-100:]  # ÏµúÍ∑º 100Í∞úÎßå Ïú†ÏßÄ

                await db.execute(
                    update(UserPreference)
                    .where(UserPreference.user_id == user_id)
                    .values(
                        viewed_properties=viewed,
                        updated_at=datetime.now()
                    )
                )

            await db.commit()

    # ============================================================================
    # 3. ÏóîÌã∞Ìã∞ Ï∂îÏ†Å Í¥ÄÎ¶¨
    # ============================================================================

    async def update_entity_mentions(
        self,
        user_id: int,
        entities: Dict[str, List[str]],
        context: str
    ):
        """
        ÏóîÌã∞Ìã∞ Ïñ∏Í∏â ÏóÖÎç∞Ïù¥Ìä∏

        Args:
            user_id: ÏÇ¨Ïö©Ïûê ID
            entities: {"location": ["Í∞ïÎÇ®Íµ¨"], "price": ["5Ïñµ"], ...}
            context: ÏóîÌã∞Ìã∞Í∞Ä Ïñ∏Í∏âÎêú Î¨∏Îß•
        """
        async with SessionLocal() as db:
            for entity_type, values in entities.items():
                for value in values:
                    # Í∏∞Ï°¥ ÏóîÌã∞Ìã∞ Ï°∞Ìöå
                    result = await db.execute(
                        select(EntityMemory)
                        .where(
                            EntityMemory.user_id == user_id,
                            EntityMemory.entity_type == entity_type,
                            EntityMemory.entity_value == value
                        )
                    )
                    entity = result.scalar_one_or_none()

                    if not entity:
                        # ÏÉà ÏóîÌã∞Ìã∞ ÏÉùÏÑ±
                        entity = EntityMemory(
                            user_id=user_id,
                            entity_type=entity_type,
                            entity_value=value,
                            entity_context=context,
                            mention_count=1,
                            importance_score=1.0,
                            first_mentioned_at=datetime.now(),
                            last_mentioned_at=datetime.now()
                        )
                        db.add(entity)
                    else:
                        # Í∏∞Ï°¥ ÏóîÌã∞Ìã∞ ÏóÖÎç∞Ïù¥Ìä∏
                        new_count = entity.mention_count + 1
                        await db.execute(
                            update(EntityMemory)
                            .where(EntityMemory.id == entity.id)
                            .values(
                                mention_count=new_count,
                                importance_score=float(new_count),  # Í∞ÑÎã®Ìïú Ï§ëÏöîÎèÑ Í≥ÑÏÇ∞
                                entity_context=context,
                                last_mentioned_at=datetime.now()
                            )
                        )

            await db.commit()

    async def get_important_entities(
        self,
        user_id: int,
        entity_type: Optional[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Ï§ëÏöî ÏóîÌã∞Ìã∞ Ï°∞Ìöå (ÎπàÎèÑ Í∏∞Î∞ò)

        Args:
            user_id: ÏÇ¨Ïö©Ïûê ID
            entity_type: ÏóîÌã∞Ìã∞ ÌÉÄÏûÖ ÌïÑÌÑ∞ (NoneÏù¥Î©¥ Ï†ÑÏ≤¥)
            limit: ÏµúÎåÄ Í∞úÏàò

        Returns:
            ÏóîÌã∞Ìã∞ Î¶¨Ïä§Ìä∏ (Ï§ëÏöîÎèÑ Ïàú)
        """
        async with SessionLocal() as db:
            query = select(EntityMemory).where(EntityMemory.user_id == user_id)

            if entity_type:
                query = query.where(EntityMemory.entity_type == entity_type)

            query = query.order_by(EntityMemory.importance_score.desc()).limit(limit)

            result = await db.execute(query)
            entities = result.scalars().all()

            return [
                {
                    "entity_type": e.entity_type,
                    "entity_value": e.entity_value,
                    "mention_count": e.mention_count,
                    "importance_score": e.importance_score,
                    "last_mentioned_at": e.last_mentioned_at.isoformat()
                }
                for e in entities
            ]

    # ============================================================================
    # 4. ÌÜµÍ≥Ñ Î∞è Î∂ÑÏÑù
    # ============================================================================

    async def get_user_statistics(self, user_id: int) -> Dict[str, Any]:
        """ÏÇ¨Ïö©Ïûê ÌôúÎèô ÌÜµÍ≥Ñ"""
        async with SessionLocal() as db:
            # Ï¥ù ÎåÄÌôî Ïàò
            total_conversations = await db.scalar(
                select(func.count(ConversationMemory.id))
                .where(ConversationMemory.user_id == user_id)
            )

            # ÏùòÎèÑÎ≥Ñ ÌÜµÍ≥Ñ
            intent_stats = await db.execute(
                select(
                    ConversationMemory.intent_type,
                    func.count(ConversationMemory.id).label('count')
                )
                .where(ConversationMemory.user_id == user_id)
                .group_by(ConversationMemory.intent_type)
            )
            intent_distribution = {row.intent_type: row.count for row in intent_stats}

            # ÏµúÍ∑º ÌôúÎèô
            last_conversation = await db.execute(
                select(ConversationMemory)
                .where(ConversationMemory.user_id == user_id)
                .order_by(ConversationMemory.created_at.desc())
                .limit(1)
            )
            last = last_conversation.scalar_one_or_none()

            return {
                "total_conversations": total_conversations,
                "intent_distribution": intent_distribution,
                "last_activity": last.created_at.isoformat() if last else None
            }
```

---

### 3.4 Planning Agent ÌÜµÌï©

**ÌååÏùº**: `backend/app/service_agent/cognitive_agents/planning_agent.py` (ÏàòÏ†ï)

```python
class PlanningAgent:
    def __init__(self, llm_context: LLMContext = None):
        self.llm_context = llm_context
        self.llm_service = LLMService(llm_context=llm_context)
        self.memory_service = LongTermMemoryService()  # ‚úÖ Ï∂îÍ∞Ä

    async def analyze_intent_with_memory(
        self,
        query: str,
        user_id: Optional[int],
        session_id: str
    ) -> Dict[str, Any]:
        """
        MemoryÎ•º ÌôúÏö©Ìïú ÏùòÎèÑ Î∂ÑÏÑù

        1. ÏµúÍ∑º ÎåÄÌôî Ïª®ÌÖçÏä§Ìä∏ Î°úÎìú
        2. ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ Î°úÎìú
        3. ÏóîÌã∞Ìã∞ Ï∂îÏ†Å
        4. Í∞úÏù∏ÌôîÎêú ÏùòÎèÑ Î∂ÑÏÑù
        """

        # 1. Í≥ºÍ±∞ ÎåÄÌôî Ïª®ÌÖçÏä§Ìä∏ (user_id ÏûàÏùÑ ÎïåÎßå)
        recent_context = []
        user_preferences = {}

        if user_id:
            recent_context = await self.memory_service.load_recent_context(
                user_id=user_id,
                limit=3  # ÏµúÍ∑º 3Í∞ú ÎåÄÌôî
            )

            user_preferences = await self.memory_service.get_user_preferences(user_id)

        # 2. LLMÏóêÍ≤å Ïª®ÌÖçÏä§Ìä∏ Ï†ÑÎã¨
        enhanced_prompt = f"""
        ÏÇ¨Ïö©Ïûê ÏßàÎ¨∏: {query}

        Í≥ºÍ±∞ ÎåÄÌôî Ïª®ÌÖçÏä§Ìä∏:
        {self._format_context(recent_context)}

        ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ:
        - ÏûêÏ£º Í≤ÄÏÉâÌïòÎäî ÏßÄÏó≠: {user_preferences.get('preferred_regions', [])}
        - ÏÑ†Ìò∏ Í∞ÄÍ≤©ÎåÄ: {user_preferences.get('preferred_price_range', {})}
        - ÏÑ†Ìò∏ Îß§Î¨º ÌÉÄÏûÖ: {user_preferences.get('preferred_property_types', [])}

        ÏúÑ Ï†ïÎ≥¥Î•º Ï∞∏Í≥†ÌïòÏó¨ ÏÇ¨Ïö©ÏûêÏùò ÏùòÎèÑÎ•º Î∂ÑÏÑùÌïòÏÑ∏Ïöî.
        ÏßÄÏó≠Ïù¥ Î™ÖÏãúÎêòÏßÄ ÏïäÏïòÎã§Î©¥ ÏÑ†Ìò∏ ÏßÄÏó≠ÏùÑ Ï†úÏïàÌïòÏÑ∏Ïöî.
        """

        # 3. ÏùòÎèÑ Î∂ÑÏÑù
        intent_result = await self.llm_service.analyze_intent(enhanced_prompt)

        # 4. ÏóîÌã∞Ìã∞ Ï∂îÏ∂ú Î∞è Ï∂îÏ†Å
        if user_id:
            entities = self._extract_entities(query)
            await self.memory_service.update_entity_mentions(
                user_id=user_id,
                entities=entities,
                context=query
            )

        return intent_result

    def _format_context(self, conversations: List[Dict]) -> str:
        """ÎåÄÌôî Ïª®ÌÖçÏä§Ìä∏ Ìè¨Îß∑ÌåÖ"""
        if not conversations:
            return "ÏóÜÏùå"

        formatted = []
        for conv in conversations:
            formatted.append(f"- User: {conv['user_query']}")
            formatted.append(f"  Assistant: {conv['assistant_response'][:100]}...")

        return "\n".join(formatted)

    def _extract_entities(self, query: str) -> Dict[str, List[str]]:
        """Í∞ÑÎã®Ìïú ÏóîÌã∞Ìã∞ Ï∂îÏ∂ú (Ï†ïÍ∑úÏãù Í∏∞Î∞ò)"""
        import re

        entities = {
            "location": [],
            "price": [],
            "property_type": [],
            "area": []
        }

        # ÏßÄÏó≠ Ï∂îÏ∂ú
        regions = ["Í∞ïÎÇ®Íµ¨", "ÏÑúÏ¥àÍµ¨", "ÏÜ°ÌååÍµ¨", "Í∞ïÎèôÍµ¨", "ÎßàÌè¨Íµ¨", "Ïö©ÏÇ∞Íµ¨", "Ï§ëÍµ¨"]
        for region in regions:
            if region in query:
                entities["location"].append(region)

        # Í∞ÄÍ≤© Ï∂îÏ∂ú
        price_match = re.findall(r'(\d+)Ïñµ', query)
        entities["price"] = [f"{p}Ïñµ" for p in price_match]

        # Îß§Î¨º ÌÉÄÏûÖ Ï∂îÏ∂ú
        if "ÏïÑÌååÌä∏" in query:
            entities["property_type"].append("ÏïÑÌååÌä∏")
        if "Ïò§ÌîºÏä§ÌÖî" in query:
            entities["property_type"].append("Ïò§ÌîºÏä§ÌÖî")

        return entities
```

---

## 4. Îëê ÏãúÏä§ÌÖúÏùò ÏÉÅÌò∏ÏûëÏö©

### 4.1 Îç∞Ïù¥ÌÑ∞ ÌùêÎ¶ÑÎèÑ

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        User Ï†ëÏÜç                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  SessionManager: WebSocket ÏÑ∏ÏÖò ÏÉùÏÑ±                          ‚îÇ
‚îÇ  ‚Üí session_id: "session-abc-123" (24h TTL)                   ‚îÇ
‚îÇ  ‚Üí user_id: 42 (Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê)                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User Query: "ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò" (ÏßÄÏó≠ ÎØ∏ÏßÄÏ†ï)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Planning Agent                                               ‚îÇ
‚îÇ  ‚îú‚îÄ Memory.load_recent_context(user_id=42)                   ‚îÇ
‚îÇ  ‚îÇ  ‚Üí ÏµúÍ∑º 3Í∞ú ÎåÄÌôî Î°úÎìú                                      ‚îÇ
‚îÇ  ‚îú‚îÄ Memory.get_user_preferences(user_id=42)                  ‚îÇ
‚îÇ  ‚îÇ  ‚Üí preferred_regions: ["Í∞ïÎÇ®Íµ¨", "ÏÑúÏ¥àÍµ¨"]                 ‚îÇ
‚îÇ  ‚îî‚îÄ LLM: "Ïù¥ ÏÇ¨Ïö©ÏûêÎäî Ï£ºÎ°ú Í∞ïÎÇ®Íµ¨Î•º Í≤ÄÏÉâÌï®"                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Search Execution                                             ‚îÇ
‚îÇ  ‚Üí "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏" Í≤ÄÏÉâ (ÏßÄÏó≠ ÏûêÎèô Ï∂îÍ∞Ä)                      ‚îÇ
‚îÇ  ‚Üí 10Í±¥ Î∞úÍ≤¨                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Response Generation                                          ‚îÇ
‚îÇ  ‚Üí "Í∞ïÎÇ®Íµ¨ÏóêÏÑú ÏïÑÌååÌä∏ 10Í±¥ÏùÑ Ï∞æÏïòÏäµÎãàÎã§"                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Memory: ÎåÄÌôî Ï†ÄÏû•                                            ‚îÇ
‚îÇ  ‚îú‚îÄ ConversationMemory.store(...)                            ‚îÇ
‚îÇ  ‚îÇ  ‚Üí query: "ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò"                                  ‚îÇ
‚îÇ  ‚îÇ  ‚Üí response: "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏ 10Í±¥..."                       ‚îÇ
‚îÇ  ‚îú‚îÄ UserPreference.update_region("Í∞ïÎÇ®Íµ¨")                   ‚îÇ
‚îÇ  ‚îÇ  ‚Üí Í∞ïÎÇ®Íµ¨ Ïπ¥Ïö¥Ìä∏ +1                                        ‚îÇ
‚îÇ  ‚îî‚îÄ EntityMemory.update(entity_type="location", value="Í∞ïÎÇ®Íµ¨")‚îÇ
‚îÇ     ‚Üí Í∞ïÎÇ®Íµ¨ Ïñ∏Í∏â +1                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 4.2 Ïã§Ï†ú ÏΩîÎìú ÌÜµÌï© ÏòàÏãú

**ÌååÏùº**: `backend/app/service_agent/supervisor/team_supervisor.py` (ÏàòÏ†ï)

```python
class TeamBasedSupervisor:
    def __init__(self, llm_context: LLMContext = None, enable_checkpointing: bool = True):
        # ... Í∏∞Ï°¥ ÏΩîÎìú ...

        # Memory Service Ï∂îÍ∞Ä
        self.memory_service = LongTermMemoryService()  # ‚úÖ Ï∂îÍ∞Ä

    async def planning_node(self, state: MainSupervisorState) -> MainSupervisorState:
        """
        Planning ÎÖ∏Îìú - Memory ÌÜµÌï©
        """
        query = state["query"]
        session_id = state["session_id"]
        user_id = state.get("user_id")  # v2.0ÏóêÏÑú Ï∂îÍ∞ÄÌïú ÌïÑÎìú

        # 1. MemoryÎ•º ÌôúÏö©Ìïú ÏùòÎèÑ Î∂ÑÏÑù
        intent_result = await self.planning_agent.analyze_intent_with_memory(
            query=query,
            user_id=user_id,
            session_id=session_id
        )

        # 2. Í≥ÑÌöç ÏàòÎ¶Ω
        plan = await self.planning_agent.create_execution_plan(intent_result)

        state["planning_state"] = {
            "analyzed_intent": intent_result,
            "execution_steps": plan["execution_steps"]
        }

        return state

    async def generate_response_node(self, state: MainSupervisorState) -> MainSupervisorState:
        """
        Response ÏÉùÏÑ± ÎÖ∏Îìú - Memory Ï†ÄÏû•
        """
        # ... Í∏∞Ï°¥ ÏùëÎãµ ÏÉùÏÑ± Î°úÏßÅ ...

        response = await self._generate_llm_response(state)
        state["final_response"] = response

        # Memory Ï†ÄÏû• (user_id ÏûàÏùÑ ÎïåÎßå)
        user_id = state.get("user_id")
        if user_id:
            session_id = state["session_id"]
            query = state["query"]

            # ÌòÑÏû¨ ÏÑ∏ÏÖòÏùò ÌÑ¥ Î≤àÌò∏ Í≥ÑÏÇ∞
            turn_number = await self._get_turn_number(session_id)

            # ÎåÄÌôî Ï†ÄÏû•
            await self.memory_service.store_conversation(
                session_id=session_id,
                user_id=user_id,
                turn_number=turn_number,
                user_query=query,
                assistant_response=response["content"],
                intent_type=state["planning_state"]["analyzed_intent"]["intent"],
                intent_confidence=state["planning_state"]["analyzed_intent"]["confidence"],
                teams_used=state.get("active_teams", []),
                tools_used=self._extract_tools_used(state),
                execution_time_ms=int(state.get("total_execution_time", 0) * 1000),
                entities=self._extract_entities(query)
            )

            # ÏÑ†Ìò∏ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            await self._update_preferences(user_id, query, state)

        return state

    async def _update_preferences(self, user_id: int, query: str, state: MainSupervisorState):
        """ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏"""
        # ÏßÄÏó≠ Ï∂îÏ∂ú
        regions = self._extract_regions(query)
        for region in regions:
            await self.memory_service.update_region_preference(user_id, region)

        # Í∞ÄÍ≤© Ï∂îÏ∂ú
        price_range = self._extract_price_range(query)
        if price_range:
            await self.memory_service.update_price_preference(
                user_id,
                price_range.get("min"),
                price_range.get("max")
            )

        # Ï°∞ÌöåÌïú Îß§Î¨º Ï∂îÍ∞Ä
        property_ids = self._extract_property_ids(state)
        for prop_id in property_ids:
            await self.memory_service.add_viewed_property(user_id, prop_id)
```

---

## 5. PostgreSQL ÌÜµÌï© Í≥ÑÌöç

### 5.1 ÌÜµÌï© ÏïÑÌÇ§ÌÖçÏ≤ò

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PostgreSQL Database                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ
‚îÇ  ‚îÇ   User Í¥ÄÎ†®       ‚îÇ  ‚îÇ  Real Estate      ‚îÇ                 ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                 ‚îÇ
‚îÇ  ‚îÇ users            ‚îÇ  ‚îÇ real_estates     ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ user_profiles    ‚îÇ  ‚îÇ transactions     ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ local_auths      ‚îÇ  ‚îÇ regions          ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ social_auths     ‚îÇ  ‚îÇ trust_scores     ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ user_favorites   ‚îÇ  ‚îÇ nearby_facilities‚îÇ                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ
‚îÇ  ‚îÇ   Chat Í¥ÄÎ†®       ‚îÇ  ‚îÇ  Memory Í¥ÄÎ†®      ‚îÇ                 ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                 ‚îÇ
‚îÇ  ‚îÇ chat_sessions    ‚îÇ  ‚îÇ conversation_    ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ chat_messages    ‚îÇ  ‚îÇ   memories       ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ                  ‚îÇ  ‚îÇ user_preferences ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ                  ‚îÇ  ‚îÇ entity_memories  ‚îÇ                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ
‚îÇ  ‚îÇ Session Í¥ÄÎ†®      ‚îÇ  ‚îÇ Checkpoint Í¥ÄÎ†®   ‚îÇ                 ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                 ‚îÇ
‚îÇ  ‚îÇ websocket_       ‚îÇ  ‚îÇ langgraph_       ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ   sessions       ‚îÇ  ‚îÇ   checkpoints    ‚îÇ                 ‚îÇ
‚îÇ  ‚îÇ                  ‚îÇ  ‚îÇ (LangGraph Í¥ÄÎ¶¨)  ‚îÇ                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### 5.2 ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Îã®Í≥Ñ

#### Phase 4-1: Checkpointer Ï†ÑÌôò (1Ï£ºÏùº)

**Î™©Ìëú**: SQLite AsyncSqliteSaver ‚Üí PostgreSQL AsyncPostgresSaver

**ÏûëÏóÖ Î™©Î°ù**:
1. **Ìå®ÌÇ§ÏßÄ ÏÑ§Ïπò**
   ```bash
   pip install "langgraph[postgres]"
   ```

2. **checkpointer.py ÏàòÏ†ï**
   ```python
   # Î≥ÄÍ≤Ω Ï†Ñ
   from langgraph.checkpoint.sqlite.aio import AsyncSqliteSaver

   # Î≥ÄÍ≤Ω ÌõÑ
   from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
   ```

3. **Ïó∞Í≤∞ Î¨∏ÏûêÏó¥ Î≥ÄÍ≤Ω**
   ```python
   # Î≥ÄÍ≤Ω Ï†Ñ
   db_path = "backend/data/system/checkpoints/default_checkpoint.db"
   checkpointer = AsyncSqliteSaver.from_conn_string(str(db_path))

   # Î≥ÄÍ≤Ω ÌõÑ
   from app.db.postgre_db import DATABASE_URL
   checkpointer = AsyncPostgresSaver.from_conn_string(DATABASE_URL)
   ```

4. **ÌÖåÏä§Ìä∏**
   - [ ] Checkpoint Ï†ÄÏû•/Î°úÎìú Ï†ïÏÉÅ ÎèôÏûë
   - [ ] Î©ÄÌã∞ ÏÑ∏ÏÖò ÎèôÏãú Ï≤òÎ¶¨
   - [ ] ÏÑ±Îä• ÎπÑÍµê (SQLite vs PostgreSQL)

**ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞Ñ**: 3Ïùº (Í∞úÎ∞ú 1Ïùº, ÌÖåÏä§Ìä∏ 2Ïùº)

---

#### Phase 4-2: SessionManager Ï†ÑÌôò (1Ï£ºÏùº)

**Î™©Ìëú**: SQLite SessionManager ‚Üí PostgreSQL WebSocketSession

**ÏûëÏóÖ Î™©Î°ù**:
1. **DB Î™®Îç∏ ÏÉùÏÑ±** (`models/session.py`)
2. **Alembic migration**
   ```bash
   alembic revision --autogenerate -m "Add WebSocketSession"
   alembic upgrade head
   ```

3. **SessionManager Î¶¨Ìå©ÌÜ†ÎßÅ** (`api/session_manager.py`)
4. **Í∏∞Ï°¥ SQLite Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò** (ÏÑ†ÌÉù)
5. **ÌÖåÏä§Ìä∏**
   - [ ] ÏÑ∏ÏÖò ÏÉùÏÑ±/Ï°∞Ìöå/ÏÇ≠Ï†ú
   - [ ] WebSocket Ïó∞Í≤∞ ÏãúÎÇòÎ¶¨Ïò§
   - [ ] ÎßåÎ£å ÏÑ∏ÏÖò Ï†ïÎ¶¨ Cron job

**ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞Ñ**: 4Ïùº (Í∞úÎ∞ú 2Ïùº, ÌÖåÏä§Ìä∏ 2Ïùº)

---

#### Phase 5: Long-term Memory Íµ¨ÌòÑ (2Ï£ºÏùº)

**Î™©Ìëú**: Long-term Memory ÏãúÏä§ÌÖú Íµ¨Ï∂ï

**ÏûëÏóÖ Î™©Î°ù**:

**Week 1: DB Î™®Îç∏ Î∞è Service Íµ¨ÌòÑ**
1. **DB Î™®Îç∏ ÏÉùÏÑ±** (`models/memory.py`)
   - ConversationMemory
   - UserPreference
   - EntityMemory

2. **Alembic migration**
   ```bash
   alembic revision --autogenerate -m "Add Long-term Memory models"
   alembic upgrade head
   ```

3. **Memory Service Íµ¨ÌòÑ** (`service_agent/memory/memory_service.py`)
   - ÎåÄÌôî Ï†ÄÏû•/Ï°∞Ìöå
   - ÏÑ†Ìò∏ÎèÑ Í¥ÄÎ¶¨
   - ÏóîÌã∞Ìã∞ Ï∂îÏ†Å

4. **Unit Test ÏûëÏÑ±**

**Week 2: Planning Agent ÌÜµÌï© Î∞è ÌÖåÏä§Ìä∏**
5. **Planning Agent ÏàòÏ†ï** (`cognitive_agents/planning_agent.py`)
   - Memory Ï°∞Ìöå Î°úÏßÅ Ï∂îÍ∞Ä
   - Í∞úÏù∏ÌôîÎêú ÏùòÎèÑ Î∂ÑÏÑù

6. **Supervisor ÌÜµÌï©** (`supervisor/team_supervisor.py`)
   - ÎåÄÌôî Ï†ÄÏû• Î°úÏßÅ Ï∂îÍ∞Ä
   - ÏÑ†Ìò∏ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏

7. **Integration Test**
   - Í≥ºÍ±∞ ÎåÄÌôî Ï∞∏Ï°∞ ÏãúÎÇòÎ¶¨Ïò§
   - ÏÑ†Ìò∏ÎèÑ Í∏∞Î∞ò Ï∂îÏ≤ú ÏãúÎÇòÎ¶¨Ïò§

8. **E2E Test Î∞è Î∞∞Ìè¨**

**ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞Ñ**: 10Ïùº (Í∞úÎ∞ú 7Ïùº, ÌÖåÏä§Ìä∏ 3Ïùº)

---

## 6. Íµ¨ÌòÑ Î°úÎìúÎßµ

### 6.1 Ï†ÑÏ≤¥ ÌÉÄÏûÑÎùºÏù∏

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Phase 1-3: property_search_results Î≤ÑÍ∑∏ ÏàòÏ†ï (1Ïùº)          ‚îÇ
‚îÇ  ‚Üí State/Context ÏÑ§Í≥Ñ v2.0 Ïã§Ìñâ                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Phase 4-1: Checkpointer PostgreSQL Ï†ÑÌôò (1Ï£ºÏùº)             ‚îÇ
‚îÇ  ‚Üí AsyncSqliteSaver ‚Üí AsyncPostgresSaver                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Phase 4-2: SessionManager PostgreSQL Ï†ÑÌôò (1Ï£ºÏùº)           ‚îÇ
‚îÇ  ‚Üí SQLite sessions.db ‚Üí PostgreSQL websocket_sessions        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Phase 5: Long-term Memory Íµ¨ÌòÑ (2Ï£ºÏùº)                      ‚îÇ
‚îÇ  ‚Üí ConversationMemory, UserPreference, EntityMemory         ‚îÇ
‚îÇ  ‚Üí Planning Agent ÌÜµÌï©                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Phase 6: Í∞úÏù∏Ìôî Í∏∞Îä• Í≥†ÎèÑÌôî (Ìñ•ÌõÑ)                          ‚îÇ
‚îÇ  ‚Üí Ï∂îÏ≤ú ÏãúÏä§ÌÖú, ÏûêÎèô ÌïÑÌÑ∞ÎßÅ, Î¨∏Îß• Ïù¥Ìï¥ Í≥†ÎèÑÌôî                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Ï¥ù ÏòàÏÉÅ Í∏∞Í∞Ñ**: ÏïΩ 4-5Ï£º

---

### 6.2 Ïö∞ÏÑ†ÏàúÏúÑÎ≥Ñ ÏûëÏóÖ

| Priority | Phase | ÏûëÏóÖ | ÏÜåÏöî ÏãúÍ∞Ñ | ÏùòÏ°¥ÏÑ± |
|----------|-------|------|----------|--------|
| P0 | 1-3 | property_search_results Î≤ÑÍ∑∏ ÏàòÏ†ï | 1Ïùº | ÏóÜÏùå |
| P1 | 4-1 | Checkpointer PostgreSQL Ï†ÑÌôò | 1Ï£ºÏùº | P0 ÏôÑÎ£å |
| P1 | 4-2 | SessionManager PostgreSQL Ï†ÑÌôò | 1Ï£ºÏùº | P0 ÏôÑÎ£å |
| P2 | 5 | Long-term Memory Íµ¨ÌòÑ | 2Ï£ºÏùº | P1 ÏôÑÎ£å |
| P3 | 6 | Í∞úÏù∏Ìôî Í∏∞Îä• Í≥†ÎèÑÌôî | Ï∂îÌõÑ | P2 ÏôÑÎ£å |

---

## 7. API ÏÑ§Í≥Ñ

### 7.1 Memory Service API

#### 7.1.1 ÎåÄÌôî Ïù¥Î†• Ï°∞Ìöå

**Endpoint**: `GET /api/memory/conversations`

**Request**:
```json
{
    "user_id": 42,
    "limit": 5,
    "session_id": "optional"
}
```

**Response**:
```json
{
    "conversations": [
        {
            "turn_number": 1,
            "user_query": "Í∞ïÎÇ®Íµ¨ 5Ïñµ Ïù¥Ìïò ÏïÑÌååÌä∏ Ï∞æÏïÑÏ§ò",
            "assistant_response": "Í∞ïÎÇ®Íµ¨ÏóêÏÑú 10Í±¥ÏùÑ Ï∞æÏïòÏäµÎãàÎã§...",
            "intent_type": "property_search",
            "created_at": "2025-10-13T18:00:00Z"
        },
        {
            "turn_number": 2,
            "user_query": "Ï≤´ Î≤àÏß∏ Îß§Î¨º ÏÉÅÏÑ∏Ìûà Î≥¥Ïó¨Ï§ò",
            "assistant_response": "Í∞ïÎÇ® ÏïÑÌååÌä∏ A ÏÉÅÏÑ∏ Ï†ïÎ≥¥ÏûÖÎãàÎã§...",
            "intent_type": "property_detail",
            "created_at": "2025-10-13T18:05:00Z"
        }
    ]
}
```

---

#### 7.1.2 ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ Ï°∞Ìöå

**Endpoint**: `GET /api/memory/preferences/{user_id}`

**Response**:
```json
{
    "user_id": 42,
    "preferred_regions": ["Í∞ïÎÇ®Íµ¨", "ÏÑúÏ¥àÍµ¨"],
    "preferred_price_range": {
        "min": 40000,
        "max": 60000
    },
    "preferred_property_types": ["APARTMENT"],
    "frequent_queries": [
        {
            "query": "Í∞ïÎÇ®Íµ¨ ÏïÑÌååÌä∏",
            "count": 15,
            "last_searched": "2025-10-13T18:00:00Z"
        }
    ],
    "search_keywords": ["ÏßÄÌïòÏ≤†", "ÌïôÍµê", "Ïã†Ï∂ï"]
}
```

---

#### 7.1.3 Ï§ëÏöî ÏóîÌã∞Ìã∞ Ï°∞Ìöå

**Endpoint**: `GET /api/memory/entities/{user_id}`

**Request**:
```json
{
    "entity_type": "location",  // optional
    "limit": 10
}
```

**Response**:
```json
{
    "entities": [
        {
            "entity_type": "location",
            "entity_value": "Í∞ïÎÇ®Íµ¨",
            "mention_count": 25,
            "importance_score": 25.0,
            "last_mentioned_at": "2025-10-13T18:00:00Z"
        },
        {
            "entity_type": "location",
            "entity_value": "ÏÑúÏ¥àÍµ¨",
            "mention_count": 10,
            "importance_score": 10.0,
            "last_mentioned_at": "2025-10-12T15:30:00Z"
        }
    ]
}
```

---

#### 7.1.4 ÏÇ¨Ïö©Ïûê ÌôúÎèô ÌÜµÍ≥Ñ

**Endpoint**: `GET /api/memory/statistics/{user_id}`

**Response**:
```json
{
    "user_id": 42,
    "total_conversations": 50,
    "intent_distribution": {
        "property_search": 30,
        "market_inquiry": 15,
        "legal_consult": 5
    },
    "last_activity": "2025-10-13T18:00:00Z",
    "active_days": 15,
    "avg_daily_queries": 3.3
}
```

---

### 7.2 SessionManager API

#### 7.2.1 ÏÑ∏ÏÖò ÏÉùÏÑ±

**Endpoint**: `POST /api/sessions`

**Request**:
```json
{
    "user_id": 42,  // optional, null for non-logged-in users
    "metadata": {}  // optional
}
```

**Response**:
```json
{
    "session_id": "550e8400-e29b-41d4-a716-446655440000",
    "expires_at": "2025-10-14T18:00:00Z",
    "created_at": "2025-10-13T18:00:00Z"
}
```

---

#### 7.2.2 ÏÑ∏ÏÖò Ï°∞Ìöå

**Endpoint**: `GET /api/sessions/{session_id}`

**Response**:
```json
{
    "session_id": "550e8400-e29b-41d4-a716-446655440000",
    "user_id": 42,
    "metadata": {},
    "created_at": "2025-10-13T18:00:00Z",
    "expires_at": "2025-10-14T18:00:00Z",
    "last_activity": "2025-10-13T18:05:00Z",
    "request_count": 5
}
```

---

## 8. Ï∞∏Í≥† ÏûêÎ£å

### 8.1 Í¥ÄÎ†® Î¨∏ÏÑú

- [State/Context ÏÑ§Í≥Ñ Í≥ÑÌöçÏÑú v2.0](./plan_of_state_context_design_v2.md)
- [LangGraph Checkpointer Î¨∏ÏÑú](https://langchain-ai.github.io/langgraph/reference/checkpoints/)
- [PostgreSQL AsyncPostgresSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.postgres.PostgresSaver)

### 8.2 DB ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í∞ÄÏù¥Îìú

- [Alembic Í≥µÏãù Î¨∏ÏÑú](https://alembic.sqlalchemy.org/)
- [SQLite to PostgreSQL ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò](https://pgloader.io/)

---

## 9. Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

### Phase 4-1: Checkpointer Ï†ÑÌôò
- [ ] langgraph[postgres] Ìå®ÌÇ§ÏßÄ ÏÑ§Ïπò
- [ ] checkpointer.py AsyncPostgresSaverÎ°ú Î≥ÄÍ≤Ω
- [ ] team_supervisor.py Ï¥àÍ∏∞Ìôî ÏΩîÎìú ÏàòÏ†ï
- [ ] Unit Test ÏûëÏÑ±
- [ ] Integration Test Ïã§Ìñâ
- [ ] ÏÑ±Îä• ÎπÑÍµê (SQLite vs PostgreSQL)
- [ ] Î∞∞Ìè¨ Î∞è Î™®ÎãàÌÑ∞ÎßÅ

### Phase 4-2: SessionManager Ï†ÑÌôò
- [ ] models/session.py ÏûëÏÑ± (WebSocketSession)
- [ ] schemas/session.py ÏûëÏÑ±
- [ ] Alembic migration ÏÉùÏÑ± Î∞è Ïã§Ìñâ
- [ ] api/session_manager.py Î¶¨Ìå©ÌÜ†ÎßÅ
- [ ] Í∏∞Ï°¥ SQLite Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò (ÏÑ†ÌÉù)
- [ ] Unit Test ÏûëÏÑ±
- [ ] WebSocket Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
- [ ] ÎßåÎ£å ÏÑ∏ÏÖò Ï†ïÎ¶¨ Cron job ÌÖåÏä§Ìä∏
- [ ] Î∞∞Ìè¨ Î∞è Î™®ÎãàÌÑ∞ÎßÅ

### Phase 5: Long-term Memory Íµ¨ÌòÑ
- [ ] models/memory.py ÏûëÏÑ± (3Í∞ú Î™®Îç∏)
- [ ] Alembic migration ÏÉùÏÑ± Î∞è Ïã§Ìñâ
- [ ] service_agent/memory/memory_service.py Íµ¨ÌòÑ
- [ ] Planning Agent ÌÜµÌï©
- [ ] Supervisor ÌÜµÌï© (ÎåÄÌôî Ï†ÄÏû•)
- [ ] Unit Test ÏûëÏÑ±
- [ ] Integration Test (ÏãúÎÇòÎ¶¨Ïò§Î≥Ñ)
- [ ] E2E Test
- [ ] ÏÑ±Îä• ÏµúÏ†ÅÌôî (Ïù∏Îç±Ïä§, ÏøºÎ¶¨)
- [ ] Î∞∞Ìè¨ Î∞è Î™®ÎãàÌÑ∞ÎßÅ

---

**ÏäπÏù∏Ïûê**: _______________
**ÏäπÏù∏Ïùº**: 2025-10-13
**Îã§Ïùå Í≤ÄÌÜ†Ïùº**: Phase 4-1 ÏôÑÎ£å ÌõÑ

---

## Î≥ÄÍ≤Ω Ïù¥Î†•

| Î≤ÑÏ†Ñ | ÎÇ†Ïßú | Î≥ÄÍ≤Ω ÎÇ¥Ïö© | ÏûëÏÑ±Ïûê |
|------|------|----------|--------|
| v1.0 | 2025-10-13 | Ï¥àÏïà ÏûëÏÑ± - SessionManager vs Memory ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥Ñ | Claude Code |

// ============================================================================
// HolmesNyangz Simplified Database Schema (Unified Naming)
// ============================================================================
// Purpose: Minimal schema for chat message persistence + state management
// Total Tables: 6 (Core: 2, Checkpoint: 4)
//
// Key Change: ALL tables use "session_id" (not "thread_id")
//
// Usage:
// 1. Copy all content below
// 2. Go to https://dbdiagram.io/d
// 3. Paste into the editor
// ============================================================================

// ============================================================================
// Core Tables (2 tables only!)
// ============================================================================

Table chat_sessions {
  session_id varchar(100) [pk, note: 'Session ID (unified across all tables)']
  user_id integer [not null, default: 1, note: 'User ID (default: 1 - auth not implemented yet)']
  title varchar(200) [not null, default: '새 대화', note: 'Session title (auto-generated from first message)']
  created_at timestamp [not null, default: `now()`]
  updated_at timestamp [not null, default: `now()`]

  indexes {
    user_id
    (user_id, updated_at)
  }

  Note: '''
  GPT-style chat sessions
  - Each session = independent conversation
  - session_id is used consistently across all tables
  - user_id currently defaults to 1 (authentication not implemented)
  '''
}

Table chat_messages {
  id serial [pk]
  session_id varchar(100) [not null, ref: > chat_sessions.session_id]
  role varchar(20) [not null, note: 'user | assistant | system']
  content text [not null, note: 'Message content']
  created_at timestamp [not null, default: `now()`]

  indexes {
    session_id
    (session_id, created_at)
  }

  Note: 'Chat message history for UI display'
}

// ============================================================================
// LangGraph Checkpoint Tables (4 tables - LangGraph standard)
// ============================================================================

Table checkpoints {
  session_id text [not null, note: 'Session ID (same as chat_sessions.session_id)']
  checkpoint_ns text [not null, default: '']
  checkpoint_id text [not null]
  parent_checkpoint_id text
  type text
  checkpoint jsonb [not null]
  metadata jsonb [not null, default: `{}`]

  indexes {
    session_id
    (session_id, checkpoint_ns, checkpoint_id) [pk]
  }

  Note: 'LangGraph state snapshots for pause/resume'
}

Table checkpoint_blobs {
  session_id text [not null]
  checkpoint_ns text [not null, default: '']
  channel text [not null]
  version text [not null]
  type text [not null]
  blob bytea

  indexes {
    (session_id, checkpoint_ns, channel, version) [pk]
  }

  Note: 'LangGraph binary data storage'
}

Table checkpoint_writes {
  session_id text [not null]
  checkpoint_ns text [not null, default: '']
  checkpoint_id text [not null]
  task_id text [not null]
  idx integer [not null]
  channel text [not null]
  type text
  blob bytea [not null]

  indexes {
    session_id
    (session_id, checkpoint_ns, checkpoint_id, task_id, idx) [pk]
  }

  Note: 'LangGraph incremental state updates'
}

Table checkpoint_migrations {
  v integer [pk]

  Note: 'LangGraph schema version tracking'
}

// ============================================================================
// Key Concept: Unified Naming (ONE session_id everywhere!)
// ============================================================================

// ✅ ALL tables use the SAME column name: session_id
//
// How it works:
// 1. User clicks "새 대화" → session_id = "chat_abc123"
// 2. Messages stored → chat_messages.session_id = "chat_abc123"
// 3. LangGraph state saved → checkpoints.session_id = "chat_abc123" (SAME!)
// 4. User clicks that chat → load by session_id → state auto-restored!
//
// 🎯 ONE session_id everywhere:
//    ┌─────────────────────────────────────────────────────┐
//    │ chat_sessions.session_id      = "chat_abc123"       │
//    │ chat_messages.session_id      = "chat_abc123"       │
//    │ checkpoints.session_id        = "chat_abc123"       │
//    │ checkpoint_blobs.session_id   = "chat_abc123"       │
//    │ checkpoint_writes.session_id  = "chat_abc123"       │
//    └─────────────────────────────────────────────────────┘
//
// ✨ Benefits:
//    - No confusion between "session_id" vs "thread_id"
//    - Easy JOINs: same column name everywhere
//    - Easy to understand: one session = one conversation
//
// 🔧 LangGraph Configuration:
//    - Python code: config = {"configurable": {"thread_id": session_id}}
//    - LangGraph still uses "thread_id" in config dict (LangGraph terminology)
//    - But DB uses "session_id" for consistency (our choice!)
//    - LangGraph maps config["thread_id"] → checkpoints.session_id automatically
//
// ⚠️ NOTE:
//    - LangGraph examples use "thread_id" as column name
//    - We use "session_id" for better consistency
//    - LangGraph doesn't care about column names!

// ============================================================================
// Foreign Key Relationships
// ============================================================================

// chat_messages.session_id → chat_sessions.session_id (CASCADE delete)
// checkpoints.session_id → chat_sessions.session_id (implicit, no FK constraint)
//
// Note: checkpoint tables don't have FK constraints to allow flexible cleanup

// ============================================================================
// Tables Removed (vs. original schema)
// ============================================================================

// ❌ sessions (HTTP/WebSocket) - WebSocket managed in memory
// ❌ conversation_memories - Duplicate of chat_messages
// ❌ entity_memories - Not needed for core functionality

// Total reduction: 9 tables → 6 tables (33% simpler!)
